\section{Développement du logiciel}
\subsection{Décodeurs d'entrée}
\subsection{Développement avec boost}
La prise en main de \textit{Boost} a été la principale difficulté du projet. En effet, la documentation de \textit{Boost}, celle fournie avec la librairie et disponible sur le site officiel, ne ressemble en rien aux documentations de la stl ou de java... C'est d'autant plus difficile que la philosophie de développement de \boost est assez éloignée de ce que nous connaissions juqu'alors et finalement assez éloignée de la programmation objet : la plupart des méthodes que nous utilisons sont en fait des fonctions.

Pour trouver les fonctions relatives aux objets, ou comment les utiliser, il faut parcourir une dizaine de pages web de documentation expliquant  comment appeler ces fonctions : comment créer les structures adéquates, quels arguments et structures passés en paramètres, le type de retour, etc. Cette documentation n'est pas exhaustive et manque cruellement d'exemples, elle n'est clairement pas destinée au même public que la documentations de la stl.

Enfin, les erreurs retournées par gcc à la compilation de la librairie sont incompréhensibles, c'est pourquoi nous utilisons un compilateur particulier, \verb|gfilt|, compilateur utilisant perl pour analyser les erreurs de compilation et afficher des erreurs intelligibles. 
~\\

Tout au long du projet, la méthode la plus efficace pour avancer lorsque nous bloquions sur \boost a été d'appeler à l'aide notre tuteur de projet. 

\subsection{D\'eveloppement avec Qt}
\input{part4_lib_graph}

\subsection{Expérimentation sur le code}
Notre connaissance grandissante des librairies utilisées nous a permis de pratiquer diverses expérimentations sur nos algorithmes, traitements et affichages.

\subsubsection{Expérimentation avec boost}
\paragraph{Recherche des peers\\}
\par La recherche des peers a été développé en deux étapes. La première étape fut de trouver un moyen de recenser les Peers à partir de fichier de routage uniquement, afin de permettre de trouver les cliques avec un algorithme ``maison''. Cette méthode se basait sur le ciblage des AS qui n'avaient ni client, ni peer : ce sont n\'ecessairement des stubs. A ce moment là, nous stockions plusieurs graphs dans l'objet contrôleur dont le principale, et celui sans les stubs... 

En revanche, cette méthode présupposait que le fichier était ordonné et bien que ce soit le cas avec le fichier qui nous servait de base cela ne le serait pas forcément avec tous les fichiers devant être utilisés. Et ordonner un fichier de 100000 lignes reléverait presque de la mythologie grecque s'il fallait le faire à la main. Ordonner ce fichier avec une fonction dédiée était possible, mais il fallait trouver un moyen plus ``propre'' et performant.

\par Notre tuteur de projet, Monsieur Meulle, nous a fourni un nouveau fichier, avec des relations entre AS sous la forme de triplets, permettant d'identifier tr\`es rapidement les AS feuilles.
Les liens entre AS sont plac\'ees sous la forme de triplets : {AS1, AS2, AS3} signifiant que pour joindre l'AS3, l'AS1 a du passer par l'AS2. Les AS du milieu sont donc forcément des AS de transit, les AS stubs sont alors facilement identifiables comme \'etant tous les autres... 

C'est à ce moment-là que le structure actuelle du programme a été clairement établie, nous ne stockons qu'un seul graphe dans le controlleur et celui-ci réalise un traitement de création d'un graphe spécifique en fonction de ce qui lui ait demandé. Un fonctionnement proche d'une base de données décrit en partie 3.


